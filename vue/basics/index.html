<!DOCTYPE html>
<html>
<head>
  <title>Vue 3 Basics</title>
  <style>
    .box {
      background-color: purple;
      height: 200px;
      width: 200px;
    }
    .box.two {
      background-color: red;
    }
    .box.three {
      background-color: blue;
    }
    /* This selects a dom that has the v-cloak attribute. */
    [v-cloak] {
      display: none;
    }

    input {
      margin: 10px;
      display: block;
    }
  </style>
</head>
<body>
  <!-- This "app" is the anchor component for the Vue app created by
  Vue.createApp. -->
  <!-- The v-cloak attribute is defined in css above. Basically this
  attribute stays until the app is loaded, so the #app component is not
  shown until the app is loaded, and the v-cloak would be removed by
  the app by then. -->
  <div id="app" v-cloak>
    <!-- Reference the greeting variable. The var is defined by
    the app's data function. -->
    {{ greeting }}
    <!--
      Call greet function with the greeting variable. Both the function
      and the var are defined by the app created from Vue.createApp.

      @keyup has a bunch of shortcuts that allows for adding stuff to some
      keyup events for specific keys. You can do @keyup.13 for the enter key
      as well. @keyup.right click.

      Quite a lot other events from the @ annotation, like @click.
    -->
    <!-- v-model defines a two-way binding for the variable **greeting** -->
    <input @keyup.enter="greet(greeting + '!!!')" v-model="greeting" />

    <hr />

    <!-- @click adds a click event for the button Note that it only has
    a reference to a method, defined by the app created from 
    Vue.createApp.

    @click is a syntactic sugar for v-on:click, e.g.

      v-on:click="isVisible = true"

      v-on:click="toogleBox"

    @click.prevent to prevent default form submit behavior
    @click.prevent.stop can stop propagation
    -->
    <button @click="toggleBox">Toggle Box</button>
    <button @click="toggleBox2">Toggle Box2</button>
    <!-- v-if, v-else-if, v-else directives work together for conditional
    logic. -->
    <div v-if="isVisible" class="box"></div>
    <div v-else-if="isVisible2" class="box two"></div>
    <div v-else class="box three"></div>

    <hr />
    <!-- life cycle hooks demo -->
    <h6>Life cycle hooks demo</h6>
    <button @click="toggleBoxForLifeCycle">Toggle Box</button>
    <life-cycle-test-box v-if="isVisibleForLifeCycle" />
    <hr />
    <!-- custom component defined below -->
    <h6>custom components</h6>
    <login-form />
  </div>

  <script src="http://unpkg.com/vue@next"></script>
  <script>
    // Create a Vue appplication instance and assigne it to the **app** variable.
    // The Vue app is then mounted to the #app dom later. Note how variables and methods for
    // the app is dfined using properties in the object passed to createApp.
    let app = Vue.createApp({
      // Define variables which can be used throughout the app component.
      data: function() {
        return {
          greeting: 'Hello Vue 3',
          isVisible: false,
          isVisible2: true,
          isVisibleForLifeCycle: true,
        }
      },
      // Define methods which can be used throughout the app component.
      methods: {
        // A short hand to define a function is
        // toggleBox: () {
        //   ...
        // }
        toggleBox: function() {
          // Notice how we reference the variables defined from the **data**
          // function above.
          this.isVisible = !this.isVisible
        },
        toggleBox2: function() {
          this.isVisible2 = !this.isVisible2
        },
        toggleBoxForLifeCycle: function() {
          this.isVisibleForLifeCycle = !this.isVisibleForLifeCycle;
        },
        /* you can pass in variables to this func as well */
        greet: function(greeting) {
          console.log(greeting)
        }
      },
      updated() {
        console.log('app updated')
      }
    })
    app.component('life-cycle-test-box', {
      template: `
        <div class="box"></div>
      `,
      created() {
        console.log('created');
      },
      mounted() {
        console.log('mounted');
      },
      unmounted() {
        console.log('unmounted');
      }
    })

    // We can use any options like data, methods, etc., just like the options
    // passed to Vue.createApp.
    app.component('login-form', {
      // @submit.prevent is similar to passing (event) to handleSubmit and call
      // event.preventDefault() there.
      template: `
        <form @submit.prevent="handleSubmit">
          <h1>{{ title }}</h1>

          <!-- good practice to define a key to uniquely identfy the element that you loop through for
          performan and prevent bugs. Let's say we have an array "inputs", then: -->
          <!-- <p v-for="(str, i) in inputs" :key="i">{{ str }}</p> -->

          <!-- *** original definitions of inputs *** -->
          <!-- notice the v-model variables do not need "this." prefix -->
          <!-- A email type input needs to contain @ inside the string to be valid, otherwise the
          submit is not triggered -->
          <!--
          <input type="email" v-model="email" />
          <input type="password" v-model="password" />
          -->
          <!-- *** end of original definitions of inputs *** -->

          <!-- *** non-for-loop version of using custom-input -->
          <!-- When we pass the value of the the emailLabel variable from login-form
          to another component, custom-input, we have to use v-bind:label, in which the "label"
          is a property needed by the custom-input component.

          The "v-bind:" attribute turns the "label" html attribute into a javascript so we
          can pass down a variable, e.g. emailLabel, to the property of a child component. If
          we don't need to pass down a variable, we can skip the v-bind and just do 'label="literal string"'
          to pass down a literal string to a component property.

          Because "v-bind:" is so common, we can just use ":label" instead of "v-bind:label".

          The property has to be defined using the "props" option when defining the
          custom-input component.  -->
          <!--
          Under the hood of v-model="email", it's actually :modelValue="email". It's also
          listening to events emitted by the child, for example, "update:modelValue" to
          update the value of the variable being passed in. (This allows for two-way binding
          from the parent variable, e.g. "email", to a child variable, "inputValue".
          -->
          <!--
            <custom-input v-model="email" v-bind:label="emailLabel" />
            <custom-input v-model="password"  :label="passwordLabel" />
          -->
          <!-- *** end of non-for-loop version of using custom-input -->
          <custom-input
            v-for="(input, i) in inputs"
            :key="i"
            v-model="input.value"
            :label="input.label"
            :type="input.type"
          />
          <button>Log in</button>
        </form>
      `,
      // Can only be used inside its own template. Notice that the "components"
      // property, which is needed for a component depending on components.
      // It's not needed for the global html because the global html mounted with
      // the app instance, that means the app instance can access to all components,
      // e.g. login-form can be referenced from the global html on this page.
      components: ['custom-input'],
      data() {
        return {
          title: 'Login Form',
          inputs: [
            {
              label: 'Email',
              value: '',
              type: 'email',
            },
            {
              label: 'Password',
              value: '',
              type: 'password',
            },
          ],
          // // email and password are not needed after using the inputs array
          // email: '',
          // password: '',
          // emailLabel: 'Email',
          // passwordLabel: 'Password',

        }
      },
      methods: {
        handleSubmit() {
          // console.log(this.email, this.password);
          console.log(this.inputs[0].value, this.inputs[1].value);
        }
      },
    });

    app.component('custom-input', {
      template: `
        <label>
          {{ label }}
          <input :type="type" v-model="inputValue" />
        </label>
      `,
      // Properties are read-only and passed from a parent component.
      // modelValue is a special property that is used by v-model under the hood.
      props: ['label', 'type', 'modelValue'],
      // A fancy way to define variables is to use computed instead of data options.
      // This allows for returning a evaluated expression for a variable, and setting something
      // when the variable is assigned with some value.
      computed: {
        // The reason of going through all these to update the value of a variable in the parent,
        // e.g. email, password, is because the variables from the parent cannot be really
        // changed by the custom-input child component here. We have to rely on the parent
        // listening to events to update its own variables.
        //
        // Another way maybe is to listen the change event in the <input /> of the custom-input
        // component, then calls a function passed from the parent. The parent can define
        // that function to update its own variables.
        inputValue: {
            get() {
              return this.modelValue
            },
            set(value) {
              // $emit is a special method that can emit events. "update:modelValue" is a event
              // that updates the value of modelValue. This "event" is listened by the v-model.
              this.$emit("update:modelValue", value)
            }
        }
      },
      // Not defining **data** here for the variable "label", since we are
      // passing it in as a property from the parent component through v-bind:label.
    })
    app.mount('#app')
  </script>
</body>
</html>
